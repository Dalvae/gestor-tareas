Jesus Marcano
1 jul 2025, 9:49 a.m. (hace 1 día)
para mí
GESTOR DE TAREAS
📌 Objetivo General
Crear una aplicación web para la gestión de tareas personales, que permita:

    Crear, editar, eliminar y listar tareas.
    Visualizarlas en un calendario mensual.
    Filtrarlas por estado y prioridad.

🛠️ Requerimientos Técnicos
🔹 Backend (API REST)
Implementar al menos los siguientes endpoints:

    Listar todas las tareas.
    Crear nueva tarea.
    Editar una tarea existente.
    Eliminar una tarea.

Requisitos adicionales:

    Validación: Título obligatorio, fecha debe ser futura.
    Estructura clara del proyecto y manejo adecuado de errores.

Tecnología sugerida:

    Node.js + Express ó Python + FastAPI
    Base de datos: SQLite ó archivo .json (para persistencia simple)

🔹 Frontend (Interfaz Web)
Debe incluir al menos:

    Formulario para crear y editar tareas.
    Lista de tareas con sus datos (título, fecha, prioridad, estado).
    Vista mensual tipo calendario que muestre las tareas del día.
    Filtros por estado (pendiente, completado) y prioridad.

Tecnología sugerida:

    React (con o sin hooks)
    CSS básico (puedes usar frameworks si lo deseas)
    Opcional: TypeScript

🧪 Validaciones Funcionales

    El título debe ser obligatorio.
    La fecha debe ser posterior a la actual.
    Se debe poder cambiar el estado de una tarea (pendiente → completado).
    Las tareas deben visualizarse correctamente por día en el calendario.

📁 Entrega del Proyecto

    Repositorio en GitHub (público o privado con acceso compartido).
    README que incluya:
        Instrucciones para levantar el proyecto (backend y frontend).
        Descripción general de la solución.
        Herramientas o librerías externas utilizadas.
    Proyecto debe poder correr localmente (idealmente con npm install y npm run).
    Mínimo 3-5 commits claros y descriptivos que reflejen tu proceso de trabajo.

🧠 Puntos que serán evaluados

    Calidad del código y estructura del proyecto.
    Buenas prácticas de desarrollo (nombres, componentes reutilizables, validaciones).
    Uso adecuado de tecnologías.
    Claridad del README y facilidad para levantar el proyecto.
    Organización en los commits (no todo en uno solo).
